package io.laegler.mindblowr.config;

import static com.google.common.collect.Sets.newHashSet;
import static java.lang.String.format;
import static java.util.Arrays.asList;
import static java.util.Collections.emptyList;
import static java.util.stream.Collectors.toList;
import static org.slf4j.LoggerFactory.getLogger;
import static org.springframework.web.bind.annotation.RequestMethod.DELETE;
import static org.springframework.web.bind.annotation.RequestMethod.GET;
import static org.springframework.web.bind.annotation.RequestMethod.POST;
import static org.springframework.web.bind.annotation.RequestMethod.PUT;
import static springfox.documentation.builders.PathSelectors.any;
import static springfox.documentation.builders.RequestHandlerSelectors.basePackage;
import static springfox.documentation.spi.DocumentationType.SWAGGER_2;
import com.google.common.base.Predicates;
import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import springfox.documentation.annotations.ApiIgnore;
import springfox.documentation.builders.ParameterBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.ResponseMessageBuilder;
import springfox.documentation.schema.ModelRef;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.AuthorizationScope;
import springfox.documentation.service.ClientCredentialsGrant;
import springfox.documentation.service.Contact;
import springfox.documentation.service.OAuth;
import springfox.documentation.service.Parameter;
import springfox.documentation.service.ResourceOwnerPasswordCredentialsGrant;
import springfox.documentation.service.ResponseMessage;
import springfox.documentation.service.SecurityReference;
import springfox.documentation.service.SecurityScheme;
import springfox.documentation.spi.service.contexts.SecurityContext;
import springfox.documentation.spring.web.paths.RelativePathProvider;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger.web.SecurityConfiguration;
import springfox.documentation.swagger.web.SecurityConfigurationBuilder;
import springfox.documentation.swagger2.annotations.EnableSwagger2;
import javax.annotation.PostConstruct;
import javax.servlet.ServletContext;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Locale;
import java.util.Set;

/**
 * Springfox Swagger configuration. Note: This configuration is only for the "self-hosted" Swagger
 * UI (served by the deployed service itself). Any changes here don't affect the OpenAPI YAML
 * spec-file generation. That yaml file is generated by the kongchen maven plugin.
 */
@Configuration
@EnableSwagger2
@Profile("!production")
public class SwaggerConfig {

	private static final Logger LOG = getLogger(SwaggerConfig.class);

	private static final String CODE_200 = "OK";
	private static final String CODE_201 = "Successfully created";
	private static final String CODE_204 = "No Content";
	private static final String CODE_400 = "Bad Request";
	private static final String CODE_401 = "Unauthorized";
	private static final String CODE_404 = "Not Found";
	private static final String CODE_409 = "Conflict";
	private static final String CODE_500 = "Internal Server Error";

	@Autowired
	private ServletContext servletContext;

	@Value("${spring.application.name}")
	private String artifactId;

	@Value("${version}")
	private String version;

	@Value("${api.basePath:/api/v/1}")
	private String basePath;

	@Value("${oauth2.resourceIds}")
	private String resourceIds;

	@Value("${oauth2.scopes}")
	private String scopes;

	@Value("${oauth2.grantTypes}")
	private String grantTypes;

	@Value("${oauth2.authorities}")
	private String authorities;

	// @Value("${defaults.clientId:myclient}")
	private String defaultClientId = "myclient";

	@Value("${defaults.storeSecret:test}")
	private String defaultClientSecret;

	@Value("${oauth2.host}")
	private String oauth2LocalHost;

	@Value("${oauth2.port}")
	private String oauth2LocalPort;

	@PostConstruct
	public void init() {
		LOG.info("Using Configuration: " + this.getClass().getName());
	}

	@Bean
	public Docket swaggerApi() {
		// @formatter:off
		return new Docket(SWAGGER_2)
				.pathProvider(new RelativePathProvider(servletContext) {
					@Override
					public String getApplicationBasePath() {
						return format("/%s", basePath);
					}
				})
				.directModelSubstitute(Locale.class, String.class)
				.directModelSubstitute(LocalDateTime.class, String.class)
				.directModelSubstitute(LocalDate.class, String.class)
				.ignoredParameterTypes(ApiIgnore.class).forCodeGeneration(true)
				.protocols(protocols())
//				.securitySchemes(securitySchemes())
//				.securityContexts(securityContexts())
				.useDefaultResponseMessages(false)
				.globalResponseMessage(GET, asList(
						message200(), message400(), message401(), message404(), message500()))
				.globalResponseMessage(PUT, asList(
						message200(), message400(), message401(), message404(), message409(), message500()))
				.globalResponseMessage(POST, asList(
						message201(), message400(), message401(), message409(), message500()))
				.globalResponseMessage(DELETE, asList(
						message204(), message400(), message401(), message500()))
//				.globalOperationParameters(operationParameters())
				.apiInfo(apiInfo())
				.select()
				.apis(basePackage("io.laegler.mindblowr"))
				.paths(any())
				.build();
		// @formatter:on
	}

	@Bean
	public SecurityConfiguration security() {
		return SecurityConfigurationBuilder.builder()//
				.clientId(defaultClientId)//
				.clientSecret(defaultClientSecret)//
				.appName(artifactId)//
				.scopeSeparator(" ")//
				.useBasicAuthenticationWithAccessCodeGrant(true)//
				.build();
	}

	private List<Parameter> operationParameters() {
		Parameter localeParam = new ParameterBuilder().name("accept-language").description("Locale (IETF BCP 47)").required(false)
				.modelRef(new ModelRef("string")).parameterType("header").defaultValue("en-US").build();
		Parameter authParam = new ParameterBuilder().name("authorization").description("Bearer OAuth2 Access Token").required(false)
				.modelRef(new ModelRef("string")).parameterType("header").defaultValue("Bearer 123token123").build();
		return asList(localeParam, authParam);
	}

	private List<SecurityContext> securityContexts() {
		return asList(//
				SecurityContext.builder()//
						.securityReferences(asList(SecurityReference.builder().reference("clientCredentialsGrant")
								.scopes(authScopes().toArray(new AuthorizationScope[0])).build()))//
						.forPaths(Predicates.not(PathSelectors.regex("/swagger.*|/webjars.*|v2/.*"))).build(),
				SecurityContext.builder()//
						.securityReferences(asList(
								SecurityReference.builder().reference("userPasswordGrant").scopes(authScopes().toArray(new AuthorizationScope[0])).build()))//
						.forPaths(Predicates.not(PathSelectors.regex("/swagger.*|/webjars.*|v2/.*"))).build());
	}

	private List<SecurityScheme> securitySchemes() {
		return asList(clientCredentialsGrant(), userPasswordGrant());
	}

	private SecurityScheme clientCredentialsGrant() {
		return new OAuth("clientCredentialsGrant", authScopes(), asList(new ClientCredentialsGrant(tokenUrl())));
	}

	private SecurityScheme userPasswordGrant() {
		return new OAuth("userPasswordGrant", authScopes(), asList(new ResourceOwnerPasswordCredentialsGrant(tokenUrl())));
	}

	private List<AuthorizationScope> authScopes() {
		return asList(scopes.split(",")).stream().map(s -> new AuthorizationScope(s, format("%s rights", s))).collect(toList());
	}

	private ApiInfo apiInfo() {
		return new ApiInfo(artifactId.toUpperCase() + " REST API", "For more information see confluence: https://github.org/thlaegler", version,
				"This as an early access", swaggerContact(), "Proprietary licence", "https://github.org/thlaegler", emptyList());
	}

	private String tokenUrl() {
		if (isLocal()) {
			return format("http://%s:%s/oauth2/token", oauth2LocalHost, oauth2LocalPort);
		} else {
			String basePathWithLeadingSlash = basePath.startsWith("/") ? basePath : format("/%s", basePath);
			return format("%s/oauth2/token", basePathWithLeadingSlash).replace("//", "/");
		}
	}

	private Contact swaggerContact() {
		return new Contact("Mindblowr", "https://github.org/thlaegler", "https://github.org/thlaegler");
	}

	private boolean isLocal() {
		// AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		// Optional<String> profile =
		// asList(context.getEnvironment().getActiveProfiles()).stream().filter(s ->
		// s.equalsIgnoreCase("local")).findFirst();
		// context.close();
		// return profile.isPresent();
		return basePath.equals("/");
	}

	private Set<String> protocols() {
		return isLocal() ? newHashSet("http") : newHashSet("https");
	}

	private ResponseMessage message200() {
		return new ResponseMessageBuilder().code(200).message(CODE_200).build();
	}

	private ResponseMessage message201() {
		return new ResponseMessageBuilder().code(201).message(CODE_201).build();
	}

	private ResponseMessage message204() {
		return new ResponseMessageBuilder().code(500).message(CODE_204).build();
	}

	private ResponseMessage message400() {
		return new ResponseMessageBuilder().code(400).message(CODE_400).build();
	}

	private ResponseMessage message401() {
		return new ResponseMessageBuilder().code(401).message(CODE_401).build();
	}

	private ResponseMessage message404() {
		return new ResponseMessageBuilder().code(404).message(CODE_404).build();
	}

	private ResponseMessage message409() {
		return new ResponseMessageBuilder().code(409).message(CODE_409).build();
	}

	private ResponseMessage message500() {
		return new ResponseMessageBuilder().code(500).message(CODE_500).build();
	}



}
