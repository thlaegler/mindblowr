<!DOCTYPE html>
<html lang='en'>

<head>
	<title>mindblowr</title>
	<meta charset='utf-8'>
	<meta name='viewport' content='width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0'>
	<style>
		body {
			color: #61443e;
			font-family: Monospace;
			font-size: 13px;
			text-align: center;
			background-color: #efd1b5;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px;
			width: 100%;
			padding: 5px;
		}

		a {
			color: #a06851;
		}

		#message_bar {
			cursor: pointer;
			display: none;
			position: absolute;
			top: 0;
			left: 0;
			height: 50px;
			width: 100%;
			background: #000;
		}

		#show_message_bar {
			cursor: pointer;
			display: none;
			background: #000;
			width: 50px;
			height: 50px;
			position: absolute;
			top: 0;
			right: 30px;
		}
	</style>
</head>

<body>

	<div id='message_bar'>message</div>
	<div id='show_message_bar'></div>


	<input type='file' id='fileinput' />
	<input value="random" title='random' type='button' id='random' name='random' title='random' alt='random' />

	<div id='container'>
		<br />
		<br />
		<br />
		<br />
		<br />Upload YAML hierarchy to generate your world...
	</div>

	<script src='three.min.js'></script>
	<!-- <script src='OrbitControls.js'></script> -->
	<script src='FirstPersonControls.js'></script>
	<script src='ImprovedNoise.js'></script>
	<script src='Detector.js'></script>
	<script src='stats.min.js'></script>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/js-yaml/3.12.0/js-yaml.min.js'></script>
	<script>

		document.getElementById('fileinput').addEventListener('change', uploadTriggered, false);
		document.getElementById('random').addEventListener('change', randomTriggered, false);

		if (!Detector.webgl) {
			Detector.addGetWebGLMessage();
			document.getElementById('container').innerHTML = '';
		}

		var container, stats;
		var camera, controls, scene, renderer;
		var mesh, texture;
		var clock = new THREE.Clock();

		var helper;
		var rootNode;
		var vectors = [];

		var worldWidth = 64;
		var worldDepth = 64;
		var worldHeight = 256;

		// rate when going 1 further and 0.2 heigher
		var slopeRate = 2.75;

		// rate of total world size
		var branchLengthRate = 0.25;
		var branchForkAngle = 90;
		var branchWidth = 8;

		var maxDepth = 7;
		var weight = 7;
		var defaultHeight = 0;

		// var factorBranchLength = 0.8;

		//var raycaster = new THREE.Raycaster();
		//var mouse = new THREE.Vector2();
		var worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;
		var branchLength = (worldWidth * branchLengthRate);
		var ready = false;

		function randomTriggered(evt) {
			evt.target.files[0] = 'example.yaml';
			uploadTriggered(evt);
		}

		function uploadTriggered(evt) {
			//Retrieve the first (and only!) File from the FileList object
			var f = evt.target.files[0];

			if (f) {
				ready = false;
				var r = new FileReader();
				r.onload = function (e) {
					var contents = e.target.result;
				}
				r.onloaded = function (e) {
					result = e.target.result;
					ready = true;
				}
				r.readAsText(f);
				this.rootNode = jsyaml.load(r.result); // breakpoint here
			} else {
				alert('Failed to load file');
			}

			container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);

			controls = new THREE.FirstPersonControls(camera);
			controls.movementSpeed = 450;
			controls.lookSpeed = 0.4;

			//controls = new THREE.OrbitControls(camera);
			//controls.target.set( 0.0, 100.0, 0.0 );
			//controls.userPanSpeed = 100;

			scene = new THREE.Scene();
			scene.background = new THREE.Color(0xffffff);
			//scene.fog = new THREE.FogExp2( 0xefd1b5, 0.0025 );

			//var data = generateHeight( worldWidth, worldDepth );
			var data = generateTerrain(this.rootNode, worldWidth, worldDepth);

			camera.position.y = data[worldHalfWidth + worldHalfDepth * worldWidth] * 10 + 500;

			var geometry = new THREE.PlaneBufferGeometry(7500, 7500, worldWidth - 1, worldDepth - 1);
			geometry.rotateX(- Math.PI / 2);

			var vertices = geometry.attributes.position.array;

			for (var i = 0, j = 0, l = vertices.length; i < l; i++ , j += 3) {
				vertices[j + 1] = data[i] * 10;
			}

			texture = new THREE.CanvasTexture(generateTexture(data, worldWidth, worldDepth));
			texture.wrapS = THREE.ClampToEdgeWrapping;
			texture.wrapT = THREE.ClampToEdgeWrapping;

			mesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ map: texture }));
			scene.add(mesh);

			renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			container.innerHTML = '';

			container.appendChild(renderer.domElement);
			//container.addEventListener( 'mousemove', onMouseMove, false );

			stats = new Stats();
			container.appendChild(stats.dom);

			window.addEventListener('resize', onWindowResize, false);

			animate();
		}

		/**
		 * Recursive Branching
		 */
		function generateWireFrame(treeNode, line, lines, iteration) {
			if (iteration == null) {
				iteration = 0;
			}
			lines.push(line);

			console.log("Generated new line from (x=" + line.start.x + ",y=" + line.start.y + ",z=" + line.start.z + ") to (x=" + line.end.x + ",y=" + line.end.y + ",z=" + line.end.z + ")");

			if (treeNode.children != null) {
				var numberOfDirectChildren = treeNode.children.length;
				var childrenWeight = getWeight(treeNode);
				// var childSpan = 30;
				// var totalBranchSpace = childSpan * numberOfDirectChildren;
				var forkAngle = branchForkAngle / (numberOfDirectChildren - 1);
				var angle = branchForkAngle / 2;

				// Branching
				var child;
				for (child of treeNode.children) {
					generateWireFrame(
						child,
						new THREE.Line3(
							line.end.clone(),
							new THREE.Vector3(
								line.end.x + (Math.cos(angle + 90) * branchLength),
								line.end.y + (Math.sin(angle + 90) * branchLength),
								line.end.z + (slopeRate * 4)
							)
						),
						lines,
						iteration + 1
					);
					angle = angle - forkAngle;
				}
			}
			console.log("Generated Wireframes");
			return lines;
		}

		function generateParallels(lines) {
			var line;
			var lines2 = [];
			for (var i = 1; i < 4; i++) {
				for (line of lines) {
					lines2.push(new THREE.Line3(
						new THREE.Vector3(
							line.start.x + (i * branchWidth),
							line.start.y + (i * 0),
							line.start.z + (i * (slopeRate * 4))
						),
						new THREE.Vector3(
							line.end.x + (i * branchWidth),
							line.end.y + (i * 0),
							line.end.z + (i * (slopeRate * 4))
						)
					));
					lines2.push(new THREE.Line3(
						new THREE.Vector3(
							line.start.x - (i * branchWidth),
							line.start.y + (i * 0),
							line.start.z + (i * (slopeRate * 4))
						),
						new THREE.Vector3(
							line.end.x - (i * branchWidth),
							line.end.y + (i * 0),
							line.end.z + (i * (slopeRate * 4))
						)
					));
				}
			}
			return lines.concat(lines2);
			// return lines;
		}

		function getLineLength(line) {
			return Math.sqrt(Math.pow(line.start.x - line.end.x, 2) + Math.pow(line.start.x - line.end.x, 2) + Math.pow(line.start.x - line.end.x, 2));
		}

		function getGroundHeight(x, y) {
			var roundedX = Math.round(x);
			var roundedY = Math.round(y);
			if (groundHeights[roundedX] != null && groundHeights[roundedX][roundedY] != null) {
				return window.groundHeights[roundedX][roundedY];
			}
			return defaultHeight;
		}

		function setGroundHeight(point, brushWidth) {
			if (brushWidth != null) {
				var xOffset = point.x - (brushWidth / 2);
				var xOffsetEnd = point.x + (brushWidth / 2);
				for (var x1 = xOffset; x1 < xOffsetEnd; x1++) {
					var yOffset = point.y - (brushWidth / 2);
					var yOffsetEnd = point.y + (brushWidth / 2);
					for (var y1 = yOffset; y1 < yOffsetEnd; y1++) {
						setGroundHeight(new THREE.Vector3(x1, y1, point.z), null);
					}
				}
			} else {
				point = validatePoint(point);
				var existingHeight = getGroundHeight(roundedX, roundedY);
				if (existingHeight == null || (existingHeight != null && (existingHeight == defaultHeight || existingHeight == 0))) {
					var roundedX = Math.round(point.x);
					var roundedY = Math.round(point.y);
					var roundedZ = Math.round(point.z);
					window.groundHeights[roundedX][roundedY] = roundedZ;
				}
			}
		}

		function getWeight(treeNode) {
			if (treeNode.children != null) {
				return 10 * treeNode.children.length;
			}
			return 0;
		}

		function validatePoint(point) {
			if (point != null) {
				if (point.x < 0) { point.x = 0; }
				if (point.x > worldWidth - 1) { point.x = worldWidth - 1; }
				if (point.y < 0) { point.y = 0; }
				if (point.y > worldDepth - 1) { point.y = worldDepth - 1; }
				if (point.z < 0) { point.z = 0; }
				if (point.z > worldHeight - 1) { point.z = worldHeight - 1; }
				return point;
			} else {
				return null;
			}
		}

		function validateLine(line) {
			if (line != null) {
				line.start = validatePoint(line.start);
				line.end = validatePoint(line.end);
				return line
			} else {
				return null;
			}
		}

		function generateHeight(width, height) {
			var size = width * height, data = new Uint8Array(size),
				perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 100;
			for (var j = 0; j < 4; j++) {
				for (var i = 0; i < size; i++) {
					var x = i % width, y = ~~(i / width);
					data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.25);
				}

				quality *= 5;
			}
			return data;
		}

		var groundHeights = [];

		function generateTerrain(rootNode, width, height) {
			var data = new Uint8Array(width * height);
			var baseLine = new THREE.Line3(new THREE.Vector3(worldWidth / 2, 0, defaultHeight), new THREE.Vector3(worldWidth / 2, (worldWidth * branchLengthRate), 4 * slopeRate));
			var lines = [];
			lines = generateWireFrame(rootNode, baseLine, lines);
			lines = generateParallels(lines);

			// Set default height
			for (var x = 0; x < worldWidth; x++) {
				window.groundHeights[x] = [];
				for (var y = 0; y < worldDepth; y++) {
					setGroundHeight(new THREE.Vector3(x, y, defaultHeight));
				}
			}

			var line;
			for (var v = 0, len = lines.length; v < len; v++) {
				var line = validateLine(lines[v]);
				if (line != null) {
					console.log("Generating start ground height: (x=" + line.start.x + ",y=" + line.start.x + ",z=" + line.start.x + ")");
					setGroundHeight(line.start, branchWidth);

					var point = line.start.clone();
					var plusX = (line.end.x - line.start.x) / branchLength;
					var plusY = (line.end.y - line.start.y) / branchLength;
					var plusZ = (line.end.z - line.start.z) / branchLength;
					for (var j = 0; j < branchLength; j++) {
						point.x = point.x + plusX;
						point.y = point.y + plusY;
						point.z = point.z + plusZ;
						console.log("Generating ground height: (x=" + point.x + ",y=" + point.x + ",z=" + point.x + ")");
						setGroundHeight(point, branchWidth);
					}
					console.log("Generating end ground height: (x=" + line.end.x + ",y=" + line.end.x + ",z=" + line.end.x + ")");
					setGroundHeight(line.end, branchWidth);
				}

				// Draw line for debugging
				var geometry2 = new THREE.Geometry();
				line.start.z = line.start.z + 100;
				line.end.z = line.end.z + 100;
				geometry2.vertices.push(line.start);
				geometry2.vertices.push(line.end);
				var line2 = new THREE.Line(geometry2, new THREE.LineDashedMaterial({
					color: 0xff0000,
					linewidth: 1,
					scale: 1,
					dashSize: 3,
					gapSize: 1,
				}));
				scene.add(line2);
			}

			var xcoord = "| x: |";
			for (var x = 0; x < worldWidth; x++) {
				var xcoord = xcoord + " " + x + " |";
			}
			console.log(xcoord);
			for (var y = 0; y < worldDepth; y++) {
				var ycoord = "| y:" + y + "|";
				for (var x = 0; x < worldWidth; x++) {
					var i = x * worldWidth + y;
					if (groundHeights[x] != null && groundHeights[x][y] != null) {
						var height = groundHeights[x][y];
						data[i] += height;
						ycoord = ycoord + " " + height + " |";
					} else {
						ycoord = ycoord + " 0 |";
					}
				}
				console.log(ycoord);
			}
			return data;
		}

		function generateTexture(data, width, height) {
			var canvas, canvasScaled, context, image, imageData,
				level, diff, vector3, sun, shade;
			vector3 = new THREE.Vector3(0, 0, 0);
			sun = new THREE.Vector3(1, 1, 1);
			sun.normalize();
			canvas = document.createElement('canvas');
			canvas.width = width;
			canvas.height = height;
			context = canvas.getContext('2d');
			context.fillStyle = '#000';
			context.fillRect(0, 0, width, height);
			image = context.getImageData(0, 0, canvas.width, canvas.height);
			imageData = image.data;

			for (var i = 0, j = 0, l = imageData.length; i < l; i += 4, j++) {
				vector3.x = data[j - 2] - data[j + 2];
				vector3.y = 2;
				vector3.z = data[j - width * 2] - data[j + width * 2];
				vector3.normalize();
				shade = vector3.dot(sun);
				imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
				imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
				imageData[i + 2] = (shade * 96) * (0.5 + data[j] * 0.007);
			}
			context.putImageData(image, 0, 0);

			// Scaled 4x
			canvasScaled = document.createElement('canvas');
			canvasScaled.width = width * 4;
			canvasScaled.height = height * 4;
			context = canvasScaled.getContext('2d');
			context.scale(4, 4);
			context.drawImage(canvas, 0, 0);
			image = context.getImageData(0, 0, canvasScaled.width, canvasScaled.height);
			imageData = image.data;

			for (var i = 0, l = imageData.length; i < l; i += 4) {
				var v = ~~(Math.random() * 5);
				imageData[i] += v;
				imageData[i + 1] += v;
				imageData[i + 2] += v;
			}
			context.putImageData(image, 0, 0);
			return canvasScaled;
		}

		function animate() {
			requestAnimationFrame(animate);
			render();
			stats.update();
		}

		function render() {
			controls.update(clock.getDelta());
			renderer.render(scene, camera);
		}

		function onMouseMove(event) {
			mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
			mouse.y = - (event.clientY / renderer.domElement.clientHeight) * 2 + 1;
			raycaster.setFromCamera(mouse, camera);
			// See if the ray from the camera into the world hits one of our meshes
			var intersects = raycaster.intersectObject(mesh);
			// Toggle rotation bool for meshes that we clicked
			if (intersects.length > 0) {
				helper.position.set(0, 0, 0);
				helper.lookAt(intersects[0].face.normal);
				helper.position.copy(intersects[0].point);
			}
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
			controls.handleResize();
		}
	</script>

</body>

</html>